OpenShadingLanguage 1.00
# Compiled by oslc 1.11.0@OPROJECT_VERSION_RELEASE_TYPE@
# options: -DOSX -I/data/build/ratbuild/rman/_built/osxMojave_x86-64_clang10_external_release/include -I/data/build/ratbuild/rmanshare/RIS/include -I/data/build/ratbuild/rmanshare/RIS/include/common -I/data/build/ratbuild/rmanshare/RIS/pattern/osl -I/data/build/ratbuild/rmanshare/RIS/include/osl -o /data/build/ratbuild/rmanshare/_built/osxMojave_x86-64_clang10_external_release/osl/PxrInvert.osl/obj/PxrInvert.oso
shader PxrInvert	%meta{int,rfm_nodeid,1053433} %meta{string,rfm_classification,"rendernode/RenderMan/pattern/color"} %meta{string,rfh_classification,"Pattern/Color"} %meta{string,help,"Inverts one or more components of the incoming color. The input color can be in the in the RGB, HSL, or HSV color models. Note: The output is a RGB color clamped to the [0 0 0] to [1 1 1] range."} 
param	color	inputRGB	0 0 0		%meta{string,widget,"color"} %meta{string,help,"The color that you would like to invert."} %meta{string,label,"Input Color"}  %read{0,6} %write{2147483647,-1}
param	int	colorModel	0		%meta{string,widget,"mapper"} %meta{string,options,"RGB:0|HSL:1|HSV:2"} %meta{string,help,"The inputColor uses this color model."} %meta{int,connectable,0} %meta{string,label,"Color Model"}  %read{1,31} %write{2147483647,-1}
param	int	invertChannel0	1		%meta{string,widget,"checkBox"} %meta{string,help,"When enabled (set to 1) the first color channel is inverted. For example, if the color model is set to RGB, then the R channel will be inverted."} %meta{int,connectable,0} %meta{string,label,"Invert Channel 0"}  %read{7,7} %write{2147483647,-1}
param	int	invertChannel1	1		%meta{string,widget,"checkBox"} %meta{string,help,"When enabled (set to 1) the second color channel is inverted. For example, if the color model is set to RGB, then the G channel will be inverted."} %meta{int,connectable,0} %meta{string,label,"Invert Channel 1"}  %read{18,18} %write{2147483647,-1}
param	int	invertChannel2	1		%meta{string,widget,"checkBox"} %meta{string,help,"When enabled (set to 1) the third color channel is inverted. For example, if the color model is set to RGB, then the B channel will be inverted."} %meta{int,connectable,0} %meta{string,label,"Invert Channel 2"}  %read{23,23} %write{2147483647,-1}
oparam	color	resultRGB	0 0 0		%meta{string,help,"resultRGB (color)"}  %read{38,42} %write{30,39}
oparam	float	resultR	0		%meta{string,help,"resultR (float)"}  %read{2147483647,-1} %write{40,40}
oparam	float	resultG	0		%meta{string,help,"resultG (float)"}  %read{2147483647,-1} %write{41,41}
oparam	float	resultB	0		%meta{string,help,"resultB (float)"}  %read{2147483647,-1} %write{42,42}
local	color	tempC	%read{11,34} %write{0,27}
const	int	$const1	2		%read{1,42} %write{2147483647,-1}
temp	int	$tmp1	%read{2,2} %write{1,1}
const	string	$const2	"rgb"		%read{3,33} %write{2147483647,-1}
const	string	$const3	"hsv"		%read{3,30} %write{2147483647,-1}
const	int	$const4	1		%read{4,41} %write{2147483647,-1}
temp	int	$tmp2	%read{5,5} %write{4,4}
const	string	$const5	"hsl"		%read{6,33} %write{2147483647,-1}
const	int	$const6	0		%read{7,40} %write{2147483647,-1}
temp	int	$tmp3	%read{8,8} %write{7,7}
temp	int	$tmp4	%read{10,10} %write{9,9}
temp	float	$tmp5	%read{14,14} %write{13,13}
temp	float	$tmp6	%read{12,12} %write{11,11}
const	float	$const7	0.5		%read{12,12} %write{2147483647,-1}
temp	float	$tmp7	%read{13,13} %write{12,12}
const	float	$const8	1		%read{13,36} %write{2147483647,-1}
temp	float	$tmp8	%read{16,16} %write{15,15}
temp	float	$tmp9	%read{17,17} %write{16,16}
temp	int	$tmp10	%read{19,19} %write{18,18}
temp	float	$tmp11	%read{21,21} %write{20,20}
temp	float	$tmp12	%read{22,22} %write{21,21}
temp	int	$tmp13	%read{24,24} %write{23,23}
temp	float	$tmp14	%read{26,26} %write{25,25}
temp	float	$tmp15	%read{27,27} %write{26,26}
temp	int	$tmp16	%read{29,29} %write{28,28}
temp	int	$tmp17	%read{32,32} %write{31,31}
const	float	$const9	0		%read{35,35} %write{2147483647,-1}
temp	color	$tmp18	%read{39,39} %write{35,35}
temp	color	$tmp19	%read{38,38} %write{36,36}
const	string	$const10	"clamp"		%read{37,37} %write{2147483647,-1}
temp	color	$tmp20	%read{39,39} %write{38,38}
code ___main___
# PxrInvert.osl:112
#     color tempC = inputRGB;
	assign		tempC inputRGB 	%filename{"PxrInvert.osl"} %line{112} %argrw{"wr"}
# PxrInvert.osl:114
#     if (colorModel == k_HSV)
	eq		$tmp1 colorModel $const1 	%line{114} %argrw{"wrr"}
	if		$tmp1 4 7 	%argrw{"r"}
# PxrInvert.osl:115
#         tempC = transformc("rgb", "hsv", inputRGB);
	transformc	tempC $const2 $const3 inputRGB 	%line{115} %argrw{"wrrr"}
# PxrInvert.osl:116
#     else if (colorModel == k_HSL)
	eq		$tmp2 colorModel $const4 	%line{116} %argrw{"wrr"}
	if		$tmp2 7 7 	%argrw{"r"}
# PxrInvert.osl:117
#         tempC = transformc("rgb", "hsl", inputRGB);
	transformc	tempC $const2 $const5 inputRGB 	%line{117} %argrw{"wrrr"}
# PxrInvert.osl:119
#     if (invertChannel0 != 0)
	neq		$tmp3 invertChannel0 $const6 	%line{119} %argrw{"wrr"}
	if		$tmp3 18 18 	%argrw{"r"}
# PxrInvert.osl:121
#         if (colorModel != k_RGB)
	neq		$tmp4 colorModel $const6 	%line{121} %argrw{"wrr"}
	if		$tmp4 15 18 	%argrw{"r"}
# PxrInvert.osl:124
#             tempC[0] = fmod(tempC[0] + 0.5, 1.0);
	compref		$tmp6 tempC $const6 	%line{124} %argrw{"wrr"}
	add		$tmp7 $tmp6 $const7 	%argrw{"wrr"}
	fmod		$tmp5 $tmp7 $const8 	%argrw{"wrr"}
	compassign	tempC $const6 $tmp5 	%argrw{"wrr"}
# PxrInvert.osl:128
#             tempC[0] = 1 - tempC[0];
	compref		$tmp8 tempC $const6 	%line{128} %argrw{"wrr"}
	sub		$tmp9 $const8 $tmp8 	%argrw{"wrr"}
	compassign	tempC $const6 $tmp9 	%argrw{"wrr"}
# PxrInvert.osl:131
#     if (invertChannel1 != 0)
	neq		$tmp10 invertChannel1 $const6 	%line{131} %argrw{"wrr"}
	if		$tmp10 23 23 	%argrw{"r"}
# PxrInvert.osl:133
#         tempC[1] = 1 - tempC[1];
	compref		$tmp11 tempC $const4 	%line{133} %argrw{"wrr"}
	sub		$tmp12 $const8 $tmp11 	%argrw{"wrr"}
	compassign	tempC $const4 $tmp12 	%argrw{"wrr"}
# PxrInvert.osl:135
#     if (invertChannel2 != 0)
	neq		$tmp13 invertChannel2 $const6 	%line{135} %argrw{"wrr"}
	if		$tmp13 28 28 	%argrw{"r"}
# PxrInvert.osl:137
#         tempC[2] = 1 - tempC[2];
	compref		$tmp14 tempC $const1 	%line{137} %argrw{"wrr"}
	sub		$tmp15 $const8 $tmp14 	%argrw{"wrr"}
	compassign	tempC $const1 $tmp15 	%argrw{"wrr"}
# PxrInvert.osl:141
#     if (colorModel == k_HSV)
	eq		$tmp16 colorModel $const1 	%line{141} %argrw{"wrr"}
	if		$tmp16 31 35 	%argrw{"r"}
# PxrInvert.osl:142
#         resultRGB = transformc("hsv", "rgb", tempC);
	transformc	resultRGB $const3 $const2 tempC 	%line{142} %argrw{"wrrr"}
# PxrInvert.osl:143
#     else if (colorModel == k_HSL)
	eq		$tmp17 colorModel $const4 	%line{143} %argrw{"wrr"}
	if		$tmp17 34 35 	%argrw{"r"}
# PxrInvert.osl:144
#         resultRGB = transformc("hsl", "rgb", tempC);
	transformc	resultRGB $const5 $const2 tempC 	%line{144} %argrw{"wrrr"}
# PxrInvert.osl:146
#         resultRGB = tempC;
	assign		resultRGB tempC 	%line{146} %argrw{"wr"}
# PxrInvert.osl:151
#     resultRGB = clamp(resultRGB, 0, 1);
	assign		$tmp18 $const9 	%line{151} %argrw{"wr"}
	assign		$tmp19 $const8 	%argrw{"wr"}
	functioncall	$const10 40 	%argrw{"r"}
# /data/build/ratbuild/rman/_built/osxMojave_x86-64_clang10_external_release/include/shaders/stdosl.h:162
# color  clamp (color x, color minval, color maxval) { return max(min(x,maxval),minval); }
	min		$tmp20 resultRGB $tmp19 	%filename{"/data/build/ratbuild/rman/_built/osxMojave_x86-64_clang10_external_release/include/shaders/stdosl.h"} %line{162} %argrw{"wrr"}
	max		resultRGB $tmp20 $tmp18 	%argrw{"wrr"}
# PxrInvert.osl:153
#     resultR = resultRGB[0];
	compref		resultR resultRGB $const6 	%filename{"PxrInvert.osl"} %line{153} %argrw{"wrr"}
# PxrInvert.osl:154
#     resultG = resultRGB[1];
	compref		resultG resultRGB $const4 	%line{154} %argrw{"wrr"}
# PxrInvert.osl:155
#     resultB = resultRGB[2];
	compref		resultB resultRGB $const1 	%line{155} %argrw{"wrr"}
	end
